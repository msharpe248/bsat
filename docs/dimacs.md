# DIMACS CNF Format

DIMACS CNF is the **standard file format** for SAT solvers, used in SAT competitions and by industrial tools worldwide. BSAT provides full support for reading, writing, and converting DIMACS files.

## Table of Contents

1. [Overview](#overview)
2. [Format Specification](#format-specification)
3. [Reading DIMACS Files](#reading-dimacs-files)
4. [Writing DIMACS Files](#writing-dimacs-files)
5. [Solution Format](#solution-format)
6. [Examples](#examples)
7. [SAT Competition Files](#sat-competition-files)

---

## Overview

**Why DIMACS?**

- ✅ **Industry standard** - Universally recognized format
- ✅ **SAT competitions** - All competition benchmarks use DIMACS
- ✅ **Tool interoperability** - Exchange files with other SAT solvers
- ✅ **Large benchmark library** - Thousands of problems available online

**BSAT Support:**
- Read DIMACS `.cnf` files
- Write CNF formulas to DIMACS format
- Parse solution output
- Export solutions in DIMACS format
- Full error checking and validation

---

## Format Specification

### File Structure

```
c <comment line>
p cnf <num_vars> <num_clauses>
<clause> 0
<clause> 0
...
```

### Components

**1. Comment Lines** (optional)
- Start with `c`
- Can appear anywhere
- Typically contain metadata about the problem

```
c This is a comment
c Problem: example-01.cnf
c Author: John Doe
```

**2. Problem Line** (required)
- Format: `p cnf <num_vars> <num_clauses>`
- `num_vars`: Number of variables
- `num_clauses`: Number of clauses
- Must appear before any clauses

```
p cnf 5 3
```
*(5 variables, 3 clauses)*

**3. Clause Lines**
- Space-separated integers
- **Positive** number = positive literal (x)
- **Negative** number = negated literal (¬x)
- **Must end with 0** (clause terminator)
- Variables numbered 1, 2, 3, ... (NOT 0-indexed)

```
1 -2 3 0    → (x₁ ∨ ¬x₂ ∨ x₃)
-1 2 0      → (¬x₁ ∨ x₂)
5 0         → (x₅)  [unit clause]
```

### Complete Example

```
c Example SAT problem
c (x1 ∨ ¬x2) ∧ (x2 ∨ x3) ∧ (¬x1 ∨ ¬x3)
p cnf 3 3
1 -2 0
2 3 0
-1 -3 0
```

This represents:
- 3 variables: x₁, x₂, x₃
- 3 clauses
- Formula: (x₁ ∨ ¬x₂) ∧ (x₂ ∨ x₃) ∧ (¬x₁ ∨ ¬x₃)

---

## Reading DIMACS Files

### From String

```python
from bsat import parse_dimacs

dimacs_str = """
c Simple formula
p cnf 3 2
1 -2 0
2 3 0
"""

cnf = parse_dimacs(dimacs_str)
print(f"Parsed {len(cnf.clauses)} clauses")
```

### From File

```python
from bsat import read_dimacs_file

cnf = read_dimacs_file('problem.cnf')
print(f"Variables: {cnf.get_variables()}")
print(f"Clauses: {len(cnf.clauses)}")
```

### Error Handling

```python
from bsat import parse_dimacs, DIMACSParseError

try:
    cnf = parse_dimacs(dimacs_str)
except DIMACSParseError as e:
    print(f"Parse error: {e}")
```

**Common errors detected:**
- Missing problem line
- Invalid format
- Clauses not ending with 0
- Variable numbers exceeding declared count
- Invalid literals

---

## Writing DIMACS Files

### To String

```python
from bsat import CNFExpression, Clause, Literal, to_dimacs

cnf = CNFExpression([
    Clause([Literal('x1', False), Literal('x2', True)]),
    Clause([Literal('x2', False), Literal('x3', False)])
])

dimacs_str = to_dimacs(cnf, comments=['Generated by BSAT', 'Example problem'])
print(dimacs_str)
```

Output:
```
c Generated by BSAT
c Example problem
p cnf 3 2
1 -2 0
2 3 0
```

### To File

```python
from bsat import write_dimacs_file

write_dimacs_file(cnf, 'output.cnf', comments=['My SAT problem'])
```

### Roundtrip Conversion

```python
# Read → Modify → Write
cnf = read_dimacs_file('input.cnf')

# ... modify cnf ...

write_dimacs_file(cnf, 'output.cnf')
```

---

## Solution Format

### DIMACS Solution Specification

**SAT Solution:**
```
s SATISFIABLE
v 1 -2 3 -4 5 0
```

**UNSAT Solution:**
```
s UNSATISFIABLE
```

### Parsing Solutions

```python
from bsat import parse_dimacs_solution

solution_str = """
s SATISFIABLE
v 1 -2 3 0
"""

solution = parse_dimacs_solution(solution_str)
# Returns: {'x1': True, 'x2': False, 'x3': True}
```

### Generating Solutions

```python
from bsat import solution_to_dimacs

solution = {'x1': True, 'x2': False, 'x3': True, 'x4': False}
dimacs_sol = solution_to_dimacs(solution, satisfiable=True)
print(dimacs_sol)
```

Output:
```
s SATISFIABLE
v 1 -2 3 -4 0
```

### Complete Solve & Export

```python
from bsat import read_dimacs_file, solve_cdcl, solution_to_dimacs

# Read problem
cnf = read_dimacs_file('problem.cnf')

# Solve
solution = solve_cdcl(cnf)

# Export solution
if solution:
    sol_dimacs = solution_to_dimacs(solution)
    print(sol_dimacs)
else:
    print("s UNSATISFIABLE")
```

---

## Examples

### Example 1: Load and Solve

```python
from bsat import parse_dimacs, solve_sat

dimacs = """
c 3-SAT problem
p cnf 4 3
1 2 3 0
-1 -2 4 0
-3 -4 -1 0
"""

cnf = parse_dimacs(dimacs)
solution = solve_sat(cnf)

if solution:
    print(f"SAT: {solution}")
    print(f"Valid: {cnf.evaluate(solution)}")
else:
    print("UNSAT")
```

### Example 2: Generate DIMACS from Code

```python
from bsat import CNFExpression, Clause, Literal, to_dimacs

# Build formula: (a ∨ b) ∧ (¬a ∨ c) ∧ (¬b ∨ ¬c)
cnf = CNFExpression([
    Clause([Literal('a', False), Literal('b', False)]),
    Clause([Literal('a', True), Literal('c', False)]),
    Clause([Literal('b', True), Literal('c', True)])
])

# Export to DIMACS
dimacs = to_dimacs(cnf, comments=['Example from code'])
print(dimacs)

# Save to file
from bsat import write_dimacs_file
write_dimacs_file(cnf, 'example.cnf')
```

### Example 3: Convert Between Formats

```python
from bsat import CNFExpression, to_dimacs, parse_dimacs

# Start with text format
formula = "(x | y) & (~x | z) & (y | ~z)"
cnf = CNFExpression.parse(formula)

# Convert to DIMACS
dimacs = to_dimacs(cnf)
print("DIMACS format:")
print(dimacs)

# Parse back
cnf2 = parse_dimacs(dimacs)
print(f"\nParsed: {cnf2}")
```

---

## SAT Competition Files

### Where to Find Benchmarks

**SAT Competition Archives:**
- https://satcompetition.github.io/
- Thousands of benchmark instances
- Industrial and crafted problems
- Various difficulty levels

**Common benchmark categories:**
- Random 3-SAT (varying ratios)
- Industrial (circuit verification, planning)
- Crafted (pigeon-hole, mutilated chessboard)
- Application (scheduling, graph problems)

### Using Competition Files

```python
from bsat import read_dimacs_file, solve_cdcl, get_cdcl_stats

# Download a benchmark from SAT competition
cnf = read_dimacs_file('benchmark.cnf')

# Get statistics
stats_before = {
    'vars': len(cnf.get_variables()),
    'clauses': len(cnf.clauses),
    'ratio': len(cnf.clauses) / len(cnf.get_variables())
}

print(f"Problem size:")
print(f"  Variables: {stats_before['vars']}")
print(f"  Clauses: {stats_before['clauses']}")
print(f"  Ratio: {stats_before['ratio']:.2f}")

# Solve
solution, cdcl_stats = get_cdcl_stats(cnf)

print(f"\nResult: {'SAT' if solution else 'UNSAT'}")
print(f"Decisions: {cdcl_stats.decisions}")
print(f"Conflicts: {cdcl_stats.conflicts}")
```

---

## Quick Reference

```python
# Parse DIMACS
from bsat import parse_dimacs, read_dimacs_file
cnf = parse_dimacs(dimacs_string)
cnf = read_dimacs_file('problem.cnf')

# Generate DIMACS
from bsat import to_dimacs, write_dimacs_file
dimacs_str = to_dimacs(cnf, comments=['My problem'])
write_dimacs_file(cnf, 'output.cnf')

# Solutions
from bsat import parse_dimacs_solution, solution_to_dimacs
solution = parse_dimacs_solution(sol_string)
dimacs_sol = solution_to_dimacs(solution)

# Error handling
from bsat import DIMACSParseError
try:
    cnf = parse_dimacs(bad_input)
except DIMACSParseError as e:
    print(f"Error: {e}")
```

---

## Further Reading

- [CNF Data Structures](cnf.md) - Understanding BSAT's internal format
- [CDCL Solver](cdcl-solver.md) - Best solver for large DIMACS files
- [Benchmarking](benchmarking.md) - Testing on competition instances
- [Examples & Tutorials](examples.md) - More practical usage

**External Resources:**
- [DIMACS CNF Specification](http://www.satcompetition.org/2009/format-benchmarks2009.html)
- [SATLIB Benchmark Problems](https://www.cs.ubc.ca/~hoos/SATLIB/benchm.html)
- [SAT Competition](https://satcompetition.github.io/)
